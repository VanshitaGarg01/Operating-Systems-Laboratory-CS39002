1. Be very careful to always call _exit() after an exec in the child. The exec may fail, for example, because the command doesn't exist. In that case, it's very important to for the child to exit immediately, otherwise, you will now have 2 shells, one for the parent and one for the child. Then the next time through the loop, you'll have 3 shells, and so on.thtose

2. Terminal Device Driver and Job Control
Job control, while implemented by the shell, is coordinated by the terminal device driver. The action of delivering terminal signals, like when the keys Ctr-c and Ctrl-z are pressed, are the responsible of the temrinal device driver and should only be delivered to the foreground process group. Think of the alternative, you're running an inifinite loop and you type Ctrl-C, and instead of your program exiting, your program and your shell exit because they both received the Ctlr-c message. That would be very annoying, and to ensure this does not happen, the shell uses a special system call tcsetpgrp() to indicate which job is currently in the foreground and should receive the terminal singals, like Ctrl-c. We will look at this in more detail in lab, but it's important to recongize that there is a number of things going on here.
For example, another service provided by the terminal device driver is that ensures that only the foreground process can read from stdin at a time. Try the following, running cat in the background:
It's blocked, but I said to run in the background â€¦ how could this be? When a background process tries to read from stdin this causes a signal from the terminal devic driver that says, "Hey, you shouldn't be doing that, stop," and the process does just that. It doesn't have to, thought, and this request can be ignored. For example, the shell usually ignores such request.

3. pipeline executes in parallel, not in sequence.

4. https://web.archive.org/web/20170701052127/https://www.usna.edu/Users/cs/aviv/classes/ic221/s16/lab/10/lab.html
(for tcsetpgrp)